"use strict";(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{let g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.turf=f()}})(function(){let define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){const c="function"===typeof require&&require;if(!f&&c){return c(i,!0)}if(u){return u(i,!0)}const a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}const p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){const n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"===typeof require&&require,i=0;i<t.length;i++){o(t[i])}return o}return r}()({1:[function(require,module,exports){module.exports={inside:require("@turf/inside")}},{"@turf/inside":3}],2:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});const earthRadius=6371008.8;const factors={meters:earthRadius,metres:earthRadius,millimeters:earthRadius*1e3,millimetres:earthRadius*1e3,centimeters:earthRadius*100,centimetres:earthRadius*100,kilometers:earthRadius/1e3,kilometres:earthRadius/1e3,miles:earthRadius/1609.344,nauticalmiles:earthRadius/1852,inches:earthRadius*39.37,yards:earthRadius/1.0936,feet:earthRadius*3.28084,radians:1,degrees:earthRadius/111325};const unitsFactors={meters:1,metres:1,millimeters:1e3,millimetres:1e3,centimeters:100,centimetres:100,kilometers:1/1e3,kilometres:1/1e3,miles:1/1609.344,nauticalmiles:1/1852,inches:39.37,yards:1/1.0936,feet:3.28084,radians:1/earthRadius,degrees:1/111325};const areaFactors={meters:1,metres:1,millimeters:1e6,millimetres:1e6,centimeters:1e4,centimetres:1e4,kilometers:1e-6,kilometres:1e-6,acres:247105e-9,miles:386e-9,yards:1.195990046,feet:10.763910417,inches:1550.003100006};function feature(geometry,properties,options){options=options||{};if(!isObject(options)){throw new Error("options is invalid")}const bbox=options.bbox;const id=options.id;if(geometry===undefined){throw new Error("geometry is required")}if(properties&&properties.constructor!==Object){throw new Error("properties must be an Object")}if(bbox){validateBBox(bbox)}if(id){validateId(id)}const feat={type:"Feature"};if(id){feat.id=id}if(bbox){feat.bbox=bbox}feat.properties=properties||{};feat.geometry=geometry;return feat}function geometry(type,coordinates,options){options=options||{};if(!isObject(options)){throw new Error("options is invalid")}const bbox=options.bbox;if(!type){throw new Error("type is required")}if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}if(bbox){validateBBox(bbox)}let geom;switch(type){case"Point":geom=point(coordinates).geometry;break;case"LineString":geom=lineString(coordinates).geometry;break;case"Polygon":geom=polygon(coordinates).geometry;break;case"MultiPoint":geom=multiPoint(coordinates).geometry;break;case"MultiLineString":geom=multiLineString(coordinates).geometry;break;case"MultiPolygon":geom=multiPolygon(coordinates).geometry;break;default:throw new Error(type+" is invalid")}if(bbox){geom.bbox=bbox}return geom}function point(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}if(coordinates.length<2){throw new Error("coordinates must be at least 2 numbers long")}if(!isNumber(coordinates[0])||!isNumber(coordinates[1])){throw new Error("coordinates must contain numbers")}return feature({type:"Point",coordinates:coordinates},properties,options)}function points(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}return featureCollection(coordinates.map(function(coords){return point(coords,properties)}),options)}function polygon(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}for(let i=0;i<coordinates.length;i++){const ring=coordinates[i];if(ring.length<4){throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.")}for(let j=0;j<ring[ring.length-1].length;j++){if(i===0&&j===0&&!isNumber(ring[0][0])||!isNumber(ring[0][1])){throw new Error("coordinates must contain numbers")}if(ring[ring.length-1][j]!==ring[0][j]){throw new Error("First and last Position are not equivalent.")}}}return feature({type:"Polygon",coordinates:coordinates},properties,options)}function polygons(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}return featureCollection(coordinates.map(function(coords){return polygon(coords,properties)}),options)}function lineString(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}if(coordinates.length<2){throw new Error("coordinates must be an array of two or more positions")}if(!isNumber(coordinates[0][1])||!isNumber(coordinates[0][1])){throw new Error("coordinates must contain numbers")}return feature({type:"LineString",coordinates:coordinates},properties,options)}function lineStrings(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}return featureCollection(coordinates.map(function(coords){return lineString(coords,properties)}),options)}function featureCollection(features,options){options=options||{};if(!isObject(options)){throw new Error("options is invalid")}const bbox=options.bbox;const id=options.id;if(!features){throw new Error("No features passed")}if(!Array.isArray(features)){throw new Error("features must be an Array")}if(bbox){validateBBox(bbox)}if(id){validateId(id)}const fc={type:"FeatureCollection"};if(id){fc.id=id}if(bbox){fc.bbox=bbox}fc.features=features;return fc}function multiLineString(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}return feature({type:"MultiLineString",coordinates:coordinates},properties,options)}function multiPoint(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}return feature({type:"MultiPoint",coordinates:coordinates},properties,options)}function multiPolygon(coordinates,properties,options){if(!coordinates){throw new Error("coordinates is required")}return feature({type:"MultiPolygon",coordinates:coordinates},properties,options)}function geometryCollection(geometries,properties,options){if(!geometries){throw new Error("geometries is required")}if(!Array.isArray(geometries)){throw new Error("geometries must be an Array")}return feature({type:"GeometryCollection",geometries:geometries},properties,options)}function round(num,precision){if(num===undefined||num===null||isNaN(num)){throw new Error("num is required")}if(precision&&!(precision>=0)){throw new Error("precision must be a positive number")}const multiplier=Math.pow(10,precision||0);return Math.round(num*multiplier)/multiplier}function radiansToLength(radians,units){if(radians===undefined||radians===null){throw new Error("radians is required")}if(units&&typeof units!=="string"){throw new Error("units must be a string")}const factor=factors[units||"kilometers"];if(!factor){throw new Error(units+" units is invalid")}return radians*factor}function lengthToRadians(distance,units){if(distance===undefined||distance===null){throw new Error("distance is required")}if(units&&typeof units!=="string"){throw new Error("units must be a string")}const factor=factors[units||"kilometers"];if(!factor){throw new Error(units+" units is invalid")}return distance/factor}function lengthToDegrees(distance,units){return radiansToDegrees(lengthToRadians(distance,units))}function bearingToAzimuth(bearing){if(bearing===null||bearing===undefined){throw new Error("bearing is required")}let angle=bearing%360;if(angle<0){angle+=360}return angle}function radiansToDegrees(radians){if(radians===null||radians===undefined){throw new Error("radians is required")}const degrees=radians%(2*Math.PI);return degrees*180/Math.PI}function degreesToRadians(degrees){if(degrees===null||degrees===undefined){throw new Error("degrees is required")}const radians=degrees%360;return radians*Math.PI/180}function convertLength(length,originalUnit,finalUnit){if(length===null||length===undefined){throw new Error("length is required")}if(!(length>=0)){throw new Error("length must be a positive number")}return radiansToLength(lengthToRadians(length,originalUnit),finalUnit||"kilometers")}function convertArea(area,originalUnit,finalUnit){if(area===null||area===undefined){throw new Error("area is required")}if(!(area>=0)){throw new Error("area must be a positive number")}const startFactor=areaFactors[originalUnit||"meters"];if(!startFactor){throw new Error("invalid original units")}const finalFactor=areaFactors[finalUnit||"kilometers"];if(!finalFactor){throw new Error("invalid final units")}return area/startFactor*finalFactor}function isNumber(num){return!isNaN(num)&&num!==null&&!Array.isArray(num)}function isObject(input){return!!input&&input.constructor===Object}function validateBBox(bbox){if(!bbox){throw new Error("bbox is required")}if(!Array.isArray(bbox)){throw new Error("bbox must be an Array")}if(bbox.length!==4&&bbox.length!==6){throw new Error("bbox must be an Array of 4 or 6 numbers")}bbox.forEach(function(num){if(!isNumber(num)){throw new Error("bbox must only contain numbers")}})}function validateId(id){if(!id){throw new Error("id is required")}if(["string","number"].indexOf(typeof id)===-1){throw new Error("id must be a number or a string")}}function radians2degrees(){throw new Error("method has been renamed to `radiansToDegrees`")}function degrees2radians(){throw new Error("method has been renamed to `degreesToRadians`")}function distanceToDegrees(){throw new Error("method has been renamed to `lengthToDegrees`")}function distanceToRadians(){throw new Error("method has been renamed to `lengthToRadians`")}function radiansToDistance(){throw new Error("method has been renamed to `radiansToLength`")}function bearingToAngle(){throw new Error("method has been renamed to `bearingToAzimuth`")}function convertDistance(){throw new Error("method has been renamed to `convertLength`")}exports.earthRadius=earthRadius;exports.factors=factors;exports.unitsFactors=unitsFactors;exports.areaFactors=areaFactors;exports.feature=feature;exports.geometry=geometry;exports.point=point;exports.points=points;exports.polygon=polygon;exports.polygons=polygons;exports.lineString=lineString;exports.lineStrings=lineStrings;exports.featureCollection=featureCollection;exports.multiLineString=multiLineString;exports.multiPoint=multiPoint;exports.multiPolygon=multiPolygon;exports.geometryCollection=geometryCollection;exports.round=round;exports.radiansToLength=radiansToLength;exports.lengthToRadians=lengthToRadians;exports.lengthToDegrees=lengthToDegrees;exports.bearingToAzimuth=bearingToAzimuth;exports.radiansToDegrees=radiansToDegrees;exports.degreesToRadians=degreesToRadians;exports.convertLength=convertLength;exports.convertArea=convertArea;exports.isNumber=isNumber;exports.isObject=isObject;exports.validateBBox=validateBBox;exports.validateId=validateId;exports.radians2degrees=radians2degrees;exports.degrees2radians=degrees2radians;exports.distanceToDegrees=distanceToDegrees;exports.distanceToRadians=distanceToRadians;exports.radiansToDistance=radiansToDistance;exports.bearingToAngle=bearingToAngle;exports.convertDistance=convertDistance},{}],3:[function(require,module,exports){const invariant=require("@turf/invariant");function inside(point,polygon,options){options=options||{};if(typeof options!=="object"){throw new Error("options is invalid")}const ignoreBoundary=options.ignoreBoundary;if(!point){throw new Error("point is required")}if(!polygon){throw new Error("polygon is required")}const pt=invariant.getCoord(point);let polys=invariant.getCoords(polygon);const type=polygon.geometry?polygon.geometry.type:polygon.type;const bbox=polygon.bbox;if(bbox&&inBBox(pt,bbox)===false){return false}if(type==="Polygon"){polys=[polys]}for(var i=0,insidePoly=false;i<polys.length&&!insidePoly;i++){if(inRing(pt,polys[i][0],ignoreBoundary)){let inHole=false;let k=1;while(k<polys[i].length&&!inHole){if(inRing(pt,polys[i][k],!ignoreBoundary)){inHole=true}k++}if(!inHole){insidePoly=true}}}return insidePoly}function inRing(pt,ring,ignoreBoundary){let isInside=false;if(ring[0][0]===ring[ring.length-1][0]&&ring[0][1]===ring[ring.length-1][1]){ring=ring.slice(0,ring.length-1)}for(let i=0,j=ring.length-1;i<ring.length;j=i++){const xi=ring[i][0],yi=ring[i][1];const xj=ring[j][0],yj=ring[j][1];const onBoundary=pt[1]*(xi-xj)+yi*(xj-pt[0])+yj*(pt[0]-xi)===0&&(xi-pt[0])*(xj-pt[0])<=0&&(yi-pt[1])*(yj-pt[1])<=0;if(onBoundary){return!ignoreBoundary}const intersect=yi>pt[1]!==yj>pt[1]&&pt[0]<(xj-xi)*(pt[1]-yi)/(yj-yi)+xi;if(intersect){isInside=!isInside}}return isInside}function inBBox(pt,bbox){return bbox[0]<=pt[0]&&bbox[1]<=pt[1]&&bbox[2]>=pt[0]&&bbox[3]>=pt[1]}module.exports=inside;module.exports.default=inside},{"@turf/invariant":4}],4:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});const helpers=require("@turf/helpers");function getCoord(coord){if(!coord){throw new Error("coord is required")}if(coord.type==="Feature"&&coord.geometry!==null&&coord.geometry.type==="Point"){return coord.geometry.coordinates}if(coord.type==="Point"){return coord.coordinates}if(Array.isArray(coord)&&coord.length>=2&&coord[0].length===undefined&&coord[1].length===undefined){return coord}throw new Error("coord must be GeoJSON Point or an Array of numbers")}function getCoords(coords){if(!coords){throw new Error("coords is required")}if(coords.type==="Feature"&&coords.geometry!==null){return coords.geometry.coordinates}if(coords.coordinates){return coords.coordinates}if(Array.isArray(coords)){return coords}throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function containsNumber(coordinates){if(coordinates.length>1&&helpers.isNumber(coordinates[0])&&helpers.isNumber(coordinates[1])){return true}if(Array.isArray(coordinates[0])&&coordinates[0].length){return containsNumber(coordinates[0])}throw new Error("coordinates must only contain numbers")}function geojsonType(value,type,name){if(!type||!name){throw new Error("type and name required")}if(!value||value.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+value.type)}}function featureOf(feature,type,name){if(!feature){throw new Error("No feature passed")}if(!name){throw new Error(".featureOf() requires a name")}if(!feature||feature.type!=="Feature"||!feature.geometry){throw new Error("Invalid input to "+name+", Feature with geometry required")}if(!feature.geometry||feature.geometry.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+feature.geometry.type)}}function collectionOf(featureCollection,type,name){if(!featureCollection){throw new Error("No featureCollection passed")}if(!name){throw new Error(".collectionOf() requires a name")}if(!featureCollection||featureCollection.type!=="FeatureCollection"){throw new Error("Invalid input to "+name+", FeatureCollection required")}for(let i=0;i<featureCollection.features.length;i++){const feature=featureCollection.features[i];if(!feature||feature.type!=="Feature"||!feature.geometry){throw new Error("Invalid input to "+name+", Feature with geometry required")}if(!feature.geometry||feature.geometry.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+feature.geometry.type)}}}function getGeom(geojson){if(!geojson){throw new Error("geojson is required")}if(geojson.geometry!==undefined){return geojson.geometry}if(geojson.coordinates||geojson.geometries){return geojson}throw new Error("geojson must be a valid Feature or Geometry Object")}function getGeomType(){throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType")}function getType(geojson,name){if(!geojson){throw new Error((name||"geojson")+" is required")}if(geojson.geometry&&geojson.geometry.type){return geojson.geometry.type}if(geojson.type){return geojson.type}throw new Error((name||"geojson")+" is invalid")}exports.getCoord=getCoord;exports.getCoords=getCoords;exports.containsNumber=containsNumber;exports.geojsonType=geojsonType;exports.featureOf=featureOf;exports.collectionOf=collectionOf;exports.getGeom=getGeom;exports.getGeomType=getGeomType;exports.getType=getType},{"@turf/helpers":2}]},{},[1])(1)});