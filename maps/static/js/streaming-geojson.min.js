"use strict";class StreamingGeoJSONLoader{constructor(e={}){this.onProgress=e.onProgress||(()=>{}),this.onComplete=e.onComplete||(()=>{}),this.onError=e.onError||console.error,this.abortController=null}abort(){this.abortController&&(this.abortController.abort(),this.abortController=null)}async fetch(e){this.abort(),this.abortController=new AbortController;try{const t=await fetch(e,{signal:this.abortController.signal,headers:{Accept:"application/geo+json, application/json"}});if(!t.ok){if(429===t.status){const e=t.headers.get("Retry-After"),r=e?parseInt(e,10):60,o=new Error(`Rate limit exceeded. Please wait ${r} seconds before trying again.`);throw o.isRateLimited=!0,o.retryAfter=r,o}throw new Error(`HTTP ${t.status}: ${t.statusText}`)}const r=parseInt(t.headers.get("X-Total-Count")||"0",10),o=t.headers.get("X-Cache-Status")||"UNKNOWN",s=parseInt(t.headers.get("Content-Length")||"0",10),a=t.headers.get("X-Data-Version")||null;if(console.log(`GeoJSON response: cache=${o}, total=${r}, contentLength=${s}, version=${a}`),"STREAM"!==o||r<=100){const e=await t.json();return this.onProgress(r,r),this.onComplete(e,a),e}return await this._parseStreamingResponse(t,r,s,a)}catch(e){if("AbortError"===e.name)return console.log("GeoJSON fetch aborted"),null;throw this.onError(e),e}}async _parseStreamingResponse(e,t,r=0,o=null){const s=e.body.getReader(),a=new TextDecoder;let n="";const i=[];let l=0;this.onProgress(0,t);let d=0,c=0,g=!1,p=!1,h=-1;try{let e=0;for(;;){const{done:o,value:m}=await s.read();if(o)break;e++,l+=m.length;const u=a.decode(m,{stream:!0}),y=r>0?r/t:3e3,f=Math.min(Math.round(l/y),t);this.onProgress(f,t),console.log(`Chunk ${e}: ${u.length} bytes, total: ${l}, est progress: ${f}/${t}`);for(let e=0;e<u.length;e++){const r=u[e];if(n+=r,p)p=!1;else if("\\"===r&&g)p=!0;else if('"'!==r){if(!g)if("["===r?c++:"]"===r&&c--,"{"===r)d++,2===d&&c>=1&&(h=n.length-1);else if("}"===r){if(2===d&&c>=1&&h>=0){const e=n.substring(h);try{const r=JSON.parse(e);"Feature"===r.type&&(i.push(r),this.onProgress(i.length,t))}catch(e){console.warn("Failed to parse feature:",e)}n="",h=-1}d--}}else g=!g}}a.decode();const m={type:"FeatureCollection",features:i};return this.onProgress(i.length,t),this.onComplete(m,o),m}catch(e){throw this.onError(e),e}}}function createMapProgressBar(e="map-progress-container"){let t=document.getElementById(e);if(!t){t=document.createElement("div"),t.id=e,t.className="position-absolute top-50 start-50 translate-middle",t.style.cssText="z-index: 1000; width: 300px; display: none;",t.innerHTML='\n            <div class="card shadow">\n                <div class="card-body p-3">\n                    <div class="d-flex justify-content-between mb-1">\n                        <small class="text-muted" id="map-progress-label">Loading map data...</small>\n                        <small class="text-muted" id="map-progress-text"></small>\n                    </div>\n                    <div class="progress" style="height: 8px;">\n                        <div class="progress-bar progress-bar-striped progress-bar-animated" \n                             role="progressbar" \n                             id="map-progress-bar"\n                             style="width: 0%"\n                             aria-valuenow="0" \n                             aria-valuemin="0" \n                             aria-valuemax="100">\n                        </div>\n                    </div>\n                    <small class="text-muted" id="map-progress-count"></small>\n                </div>\n            </div>\n        ';const r=document.getElementById("map")||document.body;r.style.position="relative",r.appendChild(t)}return{show(){t.style.display="block"},hide(){t.style.display="none"},showConnecting(){const e=document.getElementById("map-progress-bar"),t=document.getElementById("map-progress-text"),r=document.getElementById("map-progress-count"),o=document.getElementById("map-progress-label");o&&(o.textContent="Preparing data..."),e&&(e.style.width="100%",e.setAttribute("aria-valuenow","0")),t&&(t.textContent=""),r&&(r.textContent="")},update(e,t){const r=document.getElementById("map-progress-bar"),o=document.getElementById("map-progress-text"),s=document.getElementById("map-progress-count"),a=document.getElementById("map-progress-label");a&&(a.textContent="Loading map data...");const n=t>0?Math.round(e/t*100):0;r&&(r.style.width=`${n}%`,r.setAttribute("aria-valuenow",n)),o&&(o.textContent=`${n}%`),s&&(s.textContent=`${e.toLocaleString()} / ${t.toLocaleString()} features`)}}}async function fetchFeatureGeometriesWithProgress(e){hideMapOverlay();const t=mapConfig.featuresId?{id:mapConfig.featuresId}:e,r=buildUrl(mapConfig.featuresLayerGeometriesUrl,t),o=normalizeUrl(r);try{const e=await getFromIndexedDB(o);if(e&&e.data)return console.log("Cache hit for feature data"),renderFeatures(e.data),void("function"==typeof orderLayers&&orderLayers())}catch(e){console.warn("IndexedDB cache check failed:",e)}const s=createMapProgressBar();s.show(),s.showConnecting();const a=new StreamingGeoJSONLoader({onProgress:(e,t)=>{s.update(e,t)},onComplete:async(e,t)=>{s.hide();try{await storeInIndexedDB(o,e,t),await cleanupCache()}catch(e){console.warn("Failed to cache GeoJSON:",e)}renderFeatures(e),"function"==typeof orderLayers&&orderLayers()},onError:e=>{if(s.hide(),console.error("Error fetching feature geometries:",e),e.isRateLimited){const t=`Too many requests. Please wait ${e.retryAfter} seconds and try again.`;"function"==typeof displayErrorMessage?displayErrorMessage({message:t}):alert(t)}else"function"==typeof displayErrorMessage&&displayErrorMessage(e)}});try{await a.fetch(r)}catch(e){throw s.hide(),e}}"undefined"!=typeof window&&(window.StreamingGeoJSONLoader=StreamingGeoJSONLoader,window.createMapProgressBar=createMapProgressBar,window.fetchFeatureGeometriesWithProgress=fetchFeatureGeometriesWithProgress);