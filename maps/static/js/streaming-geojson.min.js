"use strict";class StreamingGeoJSONLoader{constructor(e={}){this.onProgress=e.onProgress||(()=>{}),this.onComplete=e.onComplete||(()=>{}),this.onError=e.onError||console.error,this.abortController=null}abort(){this.abortController&&(this.abortController.abort(),this.abortController=null)}async fetch(e){this.abort(),this.abortController=new AbortController;try{const t=await fetch(e,{signal:this.abortController.signal,headers:{Accept:"application/geo+json, application/json"}});if(!t.ok){if(429===t.status){const e=t.headers.get("Retry-After"),r=e?parseInt(e,10):60,o=new Error(`Rate limit exceeded. Please wait ${r} seconds before trying again.`);throw o.isRateLimited=!0,o.retryAfter=r,o}throw new Error(`HTTP ${t.status}: ${t.statusText}`)}const r=parseInt(t.headers.get("X-Total-Count")||"0",10),o=t.headers.get("X-Cache-Status")||"UNKNOWN",s=parseInt(t.headers.get("Content-Length")||"0",10),a=t.headers.get("X-Data-Version")||null;if(console.log(`GeoJSON response: cache=${o}, total=${r}, contentLength=${s}, version=${a}`),"STREAM"!==o||r<=100){const e=await t.json();return this.onProgress(r,r),this.onComplete(e,a),e}return await this._parseStreamingResponse(t,r,s,a)}catch(e){if("AbortError"===e.name)return console.log("GeoJSON fetch aborted"),null;throw this.onError(e),e}}async _parseStreamingResponse(e,t,r=0,o=null){const s=e.body.getReader(),a=new TextDecoder;let n="";const i=[];let l=0;this.onProgress(0,t);let c=0,d=0,h=!1,g=!1,p=-1;try{let e=0;for(;;){const{done:o,value:u}=await s.read();if(o)break;e++,l+=u.length;const m=a.decode(u,{stream:!0}),f=r>0?r/t:3e3,y=Math.min(Math.round(l/f),t);this.onProgress(y,t),console.log(`Chunk ${e}: ${m.length} bytes, total: ${l}, est progress: ${y}/${t}`);for(let e=0;e<m.length;e++){const r=m[e];if(n+=r,g)g=!1;else if("\\"===r&&h)g=!0;else if('"'!==r){if(!h)if("["===r?d++:"]"===r&&d--,"{"===r)c++,2===c&&d>=1&&(p=n.length-1);else if("}"===r){if(2===c&&d>=1&&p>=0){const e=n.substring(p);try{const r=JSON.parse(e);"Feature"===r.type&&(i.push(r),this.onProgress(i.length,t))}catch(e){console.warn("Failed to parse feature:",e)}n="",p=-1}c--}}else h=!h}}a.decode();const u={type:"FeatureCollection",features:i};return this.onProgress(i.length,t),this.onComplete(u,o),u}catch(e){throw this.onError(e),e}}}function createMapProgressBar(e="map-progress-container"){let t=document.getElementById(e);if(!t){t=document.createElement("div"),t.id=e,t.className="position-absolute top-50 start-50 translate-middle",t.style.cssText="z-index: 1000; width: 300px; display: none;",t.innerHTML='\n            <div class="card shadow">\n                <div class="card-body p-3">\n                    <div class="d-flex justify-content-between mb-1">\n                        <small class="text-muted">Loading map data...</small>\n                        <small class="text-muted" id="map-progress-text">0%</small>\n                    </div>\n                    <div class="progress" style="height: 8px;">\n                        <div class="progress-bar progress-bar-striped progress-bar-animated" \n                             role="progressbar" \n                             id="map-progress-bar"\n                             style="width: 0%"\n                             aria-valuenow="0" \n                             aria-valuemin="0" \n                             aria-valuemax="100">\n                        </div>\n                    </div>\n                    <small class="text-muted" id="map-progress-count"></small>\n                </div>\n            </div>\n        ';const r=document.getElementById("map")||document.body;r.style.position="relative",r.appendChild(t)}return{show(){t.style.display="block"},hide(){t.style.display="none"},update(e,t){const r=t>0?Math.round(e/t*100):0,o=document.getElementById("map-progress-bar"),s=document.getElementById("map-progress-text"),a=document.getElementById("map-progress-count");o&&(o.style.width=`${r}%`,o.setAttribute("aria-valuenow",r)),s&&(s.textContent=`${r}%`),a&&(a.textContent=`${e.toLocaleString()} / ${t.toLocaleString()} features`)}}}async function fetchFeatureGeometriesWithProgress(e){hideMapOverlay();const t=mapConfig.featuresId?{id:mapConfig.featuresId}:e,r=buildUrl(mapConfig.featuresLayerGeometriesUrl,t),o=normalizeUrl(r);console.log("Fetching features with progress for URL:",r);try{const e=await getFromIndexedDB(o);if(e&&e.data)return console.log("Cache hit for feature data"),void renderFeatures(e.data)}catch(e){console.warn("IndexedDB cache check failed:",e)}const s=createMapProgressBar();s.show(),s.update(0,0);const a=new StreamingGeoJSONLoader({onProgress:(e,t)=>{s.update(e,t)},onComplete:async(e,t)=>{s.hide();try{await storeInIndexedDB(o,e,t),await cleanupCache()}catch(e){console.warn("Failed to cache GeoJSON:",e)}renderFeatures(e)},onError:e=>{if(s.hide(),console.error("Error fetching feature geometries:",e),e.isRateLimited){const t=`Too many requests. Please wait ${e.retryAfter} seconds and try again.`;"function"==typeof displayErrorMessage?displayErrorMessage({message:t}):alert(t)}else"function"==typeof displayErrorMessage&&displayErrorMessage(e)}});try{await a.fetch(r)}catch(e){throw s.hide(),e}}"undefined"!=typeof window&&(window.StreamingGeoJSONLoader=StreamingGeoJSONLoader,window.createMapProgressBar=createMapProgressBar,window.fetchFeatureGeometriesWithProgress=fetchFeatureGeometriesWithProgress);